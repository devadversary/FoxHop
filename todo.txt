UI 들의 nID 관리방법 :
    UI 생성시, 사용자가 인자로 지정해준 nID를 사용하는 방식에서
    UISystem 자체에서 관리되는 카운트를 통해 nID를 생성해주는 방식으로
    변경 해야한다. 어차피 베이스 UI 클래스에 ID 필드가 있다.
    프로그래머는 UI* 를 받아서 사용 할 것이 아닌가?

UI 들은 팩토리에서 생성해야 한다 :
    모든 UI 들은 기본 모션과 색상 셋트를 가지고 생성되어야 한다.
    매번 생성시마다 UI들의 모션과 색상을 지정하기엔 너무 번거로우므로
    팩토리에서 앞으로 만들 UI의 모션과 색상을 미리 갖고있고
    생성시 이 설정을 토대로 만들어주도록 한다. 
    따라서 preinit 과정도 없어지고 UI 생성도 간소화 된다.

UI 생성시 인자는 통일 되어야 한다 :
    프로그래머 입장에서는 인자가 통일 되어야 개발하기 편하다.
    또한 같은 이름의 매서드가 인자가 들쪽날쭉하면
    라이브러리 개발 자체도 혼란이 빚어지고 구조가 복잡해진다.
_______________________________________________________________________

모션 기입 방식 :
    UI별 모션종류가 다양하다. 등장모션, 소멸모션 등, 모션 종류가 다양하고
    각 모션별 하위 모션패턴도 여러개다.
    이를 전부 하나의 매서드로 모션을 기입할 수 있어야 코드가 간결해진다.
    모션기입함수(모션타입, 모션패턴, 딜레이); 일때,
    모션기입함수(등장모션, 펄스패턴, 300ms딜레이); 식으로 지정이 가능한가?

    add~~~Motion 같은 메서드들은, 모션을 기입해주고
    Set~~~ 같은 매서드들은, 기입된 모션에 따라
    기존 상태에서 새 상태로 애니메이팅 한다.

    UI_Button::InputMotion(eButtonMotionInit Motion, /*모션 패턴 추가 예정*/, int nDelay)
    에서, Pitch 도 인자로 받아야 할 것 같다.

    이후 CreateUI, pause, resume 같은 UI 상태 변화 매서드에서는
    InputMotion 또는 setter 를 이용한다. 모션 기입은 InputMotion (생성, 소멸 등),
    모션은 유지하고 상태만 바꾸는 경우앤 setter (색상변경, 위치 변경 등)

    결론 >> InputMotion 을 모션타입, 모션패턴, 피치, 딜레이 입력 받아서
            switch-case가 좀 길어지더라도 모션 등록, 기입을 한번에 끝내야 함


모션 타입 - 모션 패턴
         - 모션 패턴
         - 모션 패턴 ...

모션 타입 - 모션 패턴
         - 모션 패턴
         - 모션 패턴...

이런식으로 switch-case 구문을 전부 채워야 함.
각 모션 타입에 대해, 각 모션 패턴별로 전부...
모션 타입 10개, 모션 패턴 10개면 100개 !!!

